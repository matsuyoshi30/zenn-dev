---
title: "ãƒ©ã‚¤ãƒ–ãƒ©ãƒªåˆ©ç”¨è€…ã« panic ã‚’ recover ã•ã›ãªã„"
emoji: "ğŸ“Œ"
type: "tech"
topics: ["go"]
published: true
---

Go ã®æº–æ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã« [singleflight](https://pkg.go.dev/golang.org/x/sync/singleflight) ã¨ã„ã†é‡è¤‡ã—ãŸé–¢æ•°ã®å‘¼ã³å‡ºã—ã‚’æŠ‘æ­¢ã™ã‚‹ã‚‚ã®ãŒã‚ã‚‹ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚ŒãŸã¨ãã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°ã®ãŸã‚ã®åŒä¸€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒ Origin ã‚µãƒ¼ãƒãƒ¼ã«ä½•å›ã‚‚ç™ºè¡Œã•ã‚Œã¦ã—ã¾ã„ã€Origin ã‚µãƒ¼ãƒãƒ¼ã«é«˜è² è·ãŒã‹ã‹ã£ã¦ã—ã¾ã†ã¨ã„ã† [Thundering Herd å•é¡Œ](https://en.wikipedia.org/wiki/Thundering_herd_problem)ã¸ã®å¯¾å¿œã«ç”¨ã„ã‚‰ã‚Œã‚‹ã€‚

```go
package main

import (
	"fmt"
	"sync"
	"time"

	"golang.org/x/sync/singleflight"
)

var group singleflight.Group

func something() {
	time.Sleep(500 * time.Millisecond)
	fmt.Println("something")
}

func doSomething(n int) {
	something()
	fmt.Printf("result %d\n", n)
}

func doSomethingWithSingleFlight(n int) {
	v, _, _ := group.Do("something", func() (interface{}, error) {
		something()
		return time.Now(), nil
	})
	fmt.Printf("result %d: %s\n", n, v)
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		i := i
		wg.Add(1)
		go func() {
			defer wg.Done()
			// doSomething(i)
			doSomethingWithSingleFlight(i)
		}()
	}
	wg.Wait()
    }
```

```
# doSomething => something ã¯æŒ‡å®šå›æ•°åˆ†å®Ÿè¡Œã•ã‚Œã‚‹
something
something
result 2
something
result 1
something
something
result 0
result 4
result 3
# doSomethingWithSingleFlight => something ã¯ä¸€å›ã®ã¿å®Ÿè¡Œã•ã‚Œã‚‹
something
result 4: 2009-11-10 23:00:00.5 +0000 UTC m=+0.500000001
result 3: 2009-11-10 23:00:00.5 +0000 UTC m=+0.500000001
result 2: 2009-11-10 23:00:00.5 +0000 UTC m=+0.500000001
result 1: 2009-11-10 23:00:00.5 +0000 UTC m=+0.500000001
result 0: 2009-11-10 23:00:00.5 +0000 UTC m=+0.500000001
```

[playground](https://go.dev/play/p/gYGWmb4Rk2b)

`singleflight.Group.Do` ã®å†…éƒ¨å‡¦ç†ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚

```go
func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) {
  g.mu.Lock()
  if g.m == nil {
    g.m = make(map[string]*call)
  }
  if c, ok := g.m[key]; ok {
    c.dups++
    g.mu.Unlock()
    c.wg.Wait()

    if e, ok := c.err.(*panicError); ok {
      panic(e)
    } else if c.err == errGoexit {
      runtime.Goexit()
    }
    return c.val, c.err, true
  }
  c := new(call)
  c.wg.Add(1)
  g.m[key] = c
  g.mu.Unlock()

  g.doCall(c, key, fn)
  return c.val, c.err, c.dups > 0
}
```

ã‚„ã£ã¦ã„ã‚‹ã“ã¨ã¯ç°¡å˜ã§ã€

-   å¼•æ•°ã«å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°ã‚’è­˜åˆ¥ã™ã‚‹ key ã¨é–¢æ•°ã‚’å—ã‘å–ã‚‹
-   æœ€åˆã® Do å®Ÿè¡Œã§ã‚ã‚Œã°ã€å†…éƒ¨ã®é–¢æ•°å‘¼ã³å‡ºã—ç®¡ç†ç”¨ã® map ã‚’åˆæœŸåŒ–
-   é–¢æ•°å‘¼ã³å‡ºã—ç®¡ç†ç”¨ map ã‚’ key ã§å‚ç…§
-   ã™ã§ã«å­˜åœ¨ã™ã‚Œã°éå»ã«å‘¼ã³å‡ºã—æ¸ˆã¿ã§ã‚ã‚‹ã¨åˆ¤å®šã§ãã‚‹ã®ã§ã€çµæœã‚’å¾…ã£ã¦è¿”ã™
-   å‘¼ã³å‡ºã—ãŸã“ã¨ãŒãªã‘ã‚Œã°ã€é–¢æ•°å‘¼ã³å‡ºã—ã‚’è¡¨ã™ call æ§‹é€ ä½“ã‚’ç”Ÿæˆã—ã€é–¢æ•°å‘¼ã³å‡ºã—ç®¡ç†ç”¨ã® map ã«ç™»éŒ²ã—ã¦å‘¼ã³å‡ºã—

## go panic

é–¢æ•°ã®å®Ÿè¡Œè‡ªä½“ã¯ä»¥ä¸‹ã® `doCall` ã§è¡Œã‚ã‚Œã‚‹ã€‚

```go
func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) {
  normalReturn := false
  recovered := false

  // use double-defer to distinguish panic from runtime.Goexit,
  // more details see https://golang.org/cl/134395
  defer func() {
    // the given function invoked runtime.Goexit
    if !normalReturn && !recovered {
      c.err = errGoexit
    }

    g.mu.Lock()
    defer g.mu.Unlock()
    c.wg.Done()
    if g.m[key] == c {
      delete(g.m, key)
    }

    if e, ok := c.err.(*panicError); ok {
      // In order to prevent the waiting channels from being blocked forever,
      // needs to ensure that this panic cannot be recovered.
      if len(c.chans) > 0 {
        go panic(e)
        select {} // Keep this goroutine around so that it will appear in the crash dump.
      } else {
        panic(e)
      }
    } else if c.err == errGoexit {
      // Already in the process of goexit, no need to call again
    } else {
      // Normal return
      for _, ch := range c.chans {
        ch <- Result{c.val, c.err, c.dups > 0}
      }
    }
  }()

  func() {
    defer func() {
      if !normalReturn {
        // Ideally, we would wait to take a stack trace until we've determined
        // whether this is a panic or a runtime.Goexit.
        //
        // Unfortunately, the only way we can distinguish the two is to see
        // whether the recover stopped the goroutine from terminating, and by
        // the time we know that, the part of the stack trace relevant to the
        // panic has been discarded.
        if r := recover(); r != nil {
          c.err = newPanicError(r)
        }
      }
    }()

    c.val, c.err = fn()
    normalReturn = true
  }()

  if !normalReturn {
    recovered = true
  }
}
```

singleflight ã¯ã€ `Do` ã®ã»ã‹ã«çµæœã‚’ãƒãƒ£ãƒãƒ«ã§è¿”ã™ `DoChan` ã‚‚æä¾›ã—ã¦ã„ã‚‹ã€‚ã“ã“ã§ `DoChan` ãŒè¿”ã™ãƒãƒ£ãƒãƒ«ã¯ singleflightï¼ˆé€ä¿¡å´ï¼‰ã§ã¯é–‰ã˜ã‚‰ã‚Œãªã„ï¼ˆ[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://pkg.go.dev/golang.org/x/sync/singleflight#Group.DoChan)ã«ã‚‚è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ï¼‰ã€‚

`doCall` ã§ã¯ã€é–¢æ•°å‘¼ã³å‡ºã—ã®çµæœ panic ã‚„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã¨ãã®å‡¦ç†ã‚‚è¡Œã£ã¦ã„ã‚‹ãŒã€ã‚ãˆã¦ `go panic(e)` ã§éåŒæœŸã« panic ã‚’ç™ºç”Ÿã•ã›ã¦ `select {}` ã§ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã„ã‚‹ã€‚
`recover` ã¯åŒã˜ goroutine ä¸Šã§ç™ºç”Ÿã—ãŸ panic ã—ã‹å›å¾©ã§ããªã„ãŸã‚ã€ã“ã®ã‚ˆã†ã« `go panic` ã§æ–°ã—ãä½œæˆã—ãŸ goroutine ä¸Šã§ panic ã‚’ç™ºç”Ÿã•ã›ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€`DoChan` å‘¼ã³å‡ºã—å´ï¼ˆãƒãƒ£ãƒãƒ«å—ä¿¡å´ï¼‰ãŒ `recover` ã«ã‚ˆã£ã¦ panic ã‚’å›å¾©ã•ã›ã‚‰ã‚Œãªã„ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚

`DoChan` å‘¼ã³å‡ºã—å´ã§å›å¾©ã§ãã¦ã—ã¾ã†ã¨ã€ `DoChan` ã§é–‹ã„ãŸãƒãƒ£ãƒãƒ«ã«ãƒ‡ãƒ¼ã‚¿ãŒé€ä¿¡ã‚‚ã‚¯ãƒ­ãƒ¼ã‚ºã‚‚ã•ã‚Œãšã«å—ä¿¡å´ãŒæ°¸é ã«ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã—ã¾ã†ã®ã§ã€ã“ã‚Œã‚’é˜²ã„ã§ã„ã‚‹ã€‚

`go panic` ã¨ã„ã†ã‹ãŸã¡ã‚’åˆã‚ã¦è¦‹ãŸã®ã§ãªã‚‹ã»ã©ãªã¨ãªã£ãŸï¼ˆä¸­ã§éåŒæœŸå‡¦ç†ã‚’è¡Œã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’æ›¸ããªã‚“ã¦ã»ã¼ãªã„ã ã‚ã†ã‘ã©ï¼‰ã€‚

## å‚è€ƒ

- [é”äººãŒæ•™ãˆã‚‹Webãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°](https://gihyo.jp/book/2022/978-4-297-12846-3) Chapter7
